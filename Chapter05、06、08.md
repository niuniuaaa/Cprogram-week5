# #Chapter05、06、08

## ##Chapter05

### ###分离链接法

1.首先声明带头节点的单链表的基本数据结构

2.再声明散列表的数据结构

3.查找

1）查找一个关键字是否在散列表中，首先根据关键字值和散列函数求相应的散列值

2）根据散列值，定位散列表中相应的散列单元，接着遍历该散列单元的链表来查找该关键字值是否在该链表中

4.插入

1）将一个关键字插入到散列表中，首先先在散列表中查找该关键字是否已经存在

2）若不存在，则继续操作，根据关键字值和散列函数求相应的散列值

3）根据散列值，在相应的散列单元链表中插入该关键字值

### ###开放地址法

就是不同的key运算后指向同一个哈希表的位置，这种情况的处理方法有两个，一个是在该位置的后面找到第一个空位插入

## ##Chapter06

### ###二叉堆

核心思想：我们用树来存储所有的元素，然后我们让树的根比它的子节点的值都小就好啦。

1.插入：把x插到堆的末尾；从刚刚插入的这个节点开始，从叶子节点往根节点更新。如果这个插入的值比父节点还小，那么这个刚刚插入的值就是以其父节点为根的子树的最小值，此时需要把这个节点的值与父节点的值交换。一直往上找，直到父节点比这个新插入的元素小位置或者到达根节点。

2.删除：把堆的最后一个元素的值放到堆顶，删除最后一个元素。然后从堆顶开始，从上往下的维护堆。

3.建堆

1）对于每一个元素，调用insert函数，将这个元素插入

2）把所有的元素都拷贝到这个堆里面，我们从最后一个非叶子的子树开始，从后往前一个个小子树的维护堆序，每个小子树是从上往下的维护。

4.两个二叉堆合并

1）将两个堆的元素全部放在一块，然后对这些元素调用MAKEHEAP_LIST方法，在O(n)的时间内合并。

2）遍历其中一个堆的每个元素，将调用INSERT函数把这些元素插入到另外一个堆里面，需要O(nlogn)的时间

### ###左叉堆

1.合并

## 1）如果有一棵树是空树，则返回另一棵树；否则递归地合并 根结点较小的堆的右子树和 根结点较大的堆。

2）使形成的新堆作为较小堆的右子树。
3）如果违反了左式堆的特性，交换两个子树的位置。
4）更新Npl。

2.删除最小值/最大值：删除操作的做法相当的简单，删除左式堆的根节点，合并左右子树即可。

3.插入：将需要插入的节点当做一棵左式堆树，进行合并即可。

### ###二项队列

1.查找最小项：只需要查找每个二项树的根节点就可以了，因此时间复杂度为O(logN)。

2.合并：通过把两个队列相加在一起完成。因为有O(logN)棵树，所以合并的时间复杂度也是O(logN)。

3.插入：插入也是一种合并，只不过是把插入的结点当做B0。虽然感觉插入的时间复杂度是O(logN)，但是实际是O(1)，因为有一定的概率是被插入的二项队列没有B0。

4.删除最小：在根结点找到最小值，然后把最小值所在的树单独拿出分列为二项队列，然后把这个新的二项队列与原二项队列进行合并。每一个过程的时间复杂度为O(logN)。故加起来的时间复杂度仍为O(logN)。

## ##Chapter08

### ###不相交集合

1.建立一个新的集合

建立一个新的集合，其唯一成员（因为是其代表）就是x。因为集合是不相交的，故要求x没有在其它集合中出现过。

2.查找包含x集合的代表

返回一个指针，指向包含x的（唯一）集合的代表。

3.合并两个不相交集合

将包含x和y的动态集合合并成为一个新的集合。所得集合的代表可以是两个集合的任何成员。但在很多情况下，我们一般选择两个集合之前代表中的一个作为新的代表。

